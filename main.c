#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//是什么？为什么？怎么办？

//指针和数组
	//本章重点
		//指针的深刻理解
		//数组的深度理解
		//如何理解指针和数组的区别
		//复杂指针的理解


//指针
	//指针是什么？
		//指针就是地址
//总结：指针就是地址，指针变量是一个变量，变量内部保存的是指针（地址）数据

//重新理解变量。

	//定义一个变量，本质是在内存中根据类型来进行开辟空间。有了空间，就必须具有地址来标识空间，来方便CPU
//进行寻址。有了空间，就可以把数据保存起来。所以，目前我们先讨论变量的空间和内容这两个概念

//2. 什么是指针？
	//指针就是地址！那么地址本质是什么呢？地址是数据，那么数据可不可以被保存在变量空间里面呢？当然可以。

//3. 有没有指针变量这个概念？
	//保存指针(地址)数据的变量就叫做指针变量

//4. 指针 和 指针变量又有何不同？我们口语中的"定义一个指针"究竟是什么意思 ? 我们该如何理解这种说法？
	//严格意义上，指针和指针变量是不同的，指针就是地址值，而指针变量是C中的变量，要在特定区域开辟空间，
//要用来保存地址数据，还可以被取地址。(先分开)但是，我们经常在口语化表达的时候，又经常将这两个概念混合，
//具体原因无从考证，不过个人认为与最早的C资料(书，文档之类)的翻译有关。然后，书与书之间互相借鉴，形成了
//这样的说法。同时，简化说法，也更符合人的表达习惯，估计老外也是这么想的。(在关联)
//那么我们以后怎么认为呢？我们分开理解，但是依旧关联使用。自己使用的时候，混合使用可以。和别人讨论，最好
// 明确概念。


//我们的生活中，为何要有门牌号？
	//原因就是要提高查找效率

//类比到计算机中
	//CPU在内存中寻址的基本单位是多大？
		//在32位机器下，最多能够识别多大的物理内存？
//既然CPU寻址按照字节寻址，但是内存又很大，所以，内存可以看做众多字节的集合

//其中，每个内存字节空间，相当于一个学生宿舍，字节空间里面能放8个比特位, 就好比同学们住的八人间，每个人
//是一个比特位。每间宿舍都有门牌号就等价于每个字节空间对应的地址，即该空间对应的指针。

//32位机器，可以理解成32位地址总线
//但是计算机只认识二进制，所以一根线是如何来表示的呢？
	//一根线是在有无电信号的来表示0和1
//32位地址线同时可以传输多少个比特位？？
//答案是32个

//这32个地址线通过不同的编码，传输这不同的信息
//所谓的编址（地址）体现在地址总线的排列组合上！

//根据不同的01代码的转换，一共有2^32个地址，每个地址是1字节
//所以也就是2^32*1=2^10*2^10*2^10*2^2=4GB

//那么，为何要存在指针呢？为了CPU寻址的效率。如果没有，该怎么找在字节空间中的数据呢 ?
		//、取地址，取的是地址最小的那一个

//具体的地址，就是指针，而不是指针变量
//int main() 
//{
//	//如果给个具体的地址，将其赋值成其他的数值，在老的编译器进行编译的时候是没有问题的，但是在现在的
//	//编译器中是肯定不对的，也就是下面这段代码
//	*(int*)0x00000002 = 10;
//	//编译是编译不过去的，解释一下星，第一个星是解引用，第二个星是强制类型转换
//	return 0;
//}


//究竟该如何理解编址

//首先，必须理解，计算机内是有很多的硬件单元，而硬件单元是要互相协同工作的。所谓的协同，至少相互之间要
//能够进行数据传递。
//但是硬件与硬件之间是互相独立的，那么如何通信呢？答案很简单，用"线"连起来。
//而CPU和内存之间也是有大量的数据交互的，所以，两者必须也用线连起来。
//不过，我们今天关心一组线，叫做地址总线。
//CPU访问内存中的某个字节空间，必须知道这个字节空间在内存的什么位置，而因为内存中字节很多，所以需要给
//内存进行编址(就如同宿舍很多，需要给宿舍编号一样)
//计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的。
//钢琴 吉他 上面没有写上“都瑞咪发嗦啦”这样的信息，但演奏者照样能够准确找到每一个琴弦的每一个位置，这
//是为何？因为制造商已经在乐器硬件层面上设计好了，并且所有的演奏者都知道。本质是一种约定出来的共识！
//硬件编址也是如此\


//1、指针的内存布局

//int main()
//{
//	int a = 10;
//	int* p = &a;
//	//当画这个图的时候，int是四个字节，当10在第三个字节放的时候，int* p指向的并不是第三个字节的区域，
//	//而是指向的是第一个字节
//	return 0;
//}

//再例如：
//int main()
//{
//	int a = 0xaabbccdd;
//	int* p = &a;
//	//当进行调试的时候，会发现在内存中存储的方式是bbccddaa
//	return 0;
//}

//问题：一个整形，有4个字节，那么应该有4个地址！那么&a取了哪一个地址?那么如何全部访问这4个字节呢？
//就是找到这个地址的起始位置，然后根据类型，连续访问我们的四个字节

//如何正确的画出指针指向图？
	//要么指向最左边，要么指向最右边，反正不能指向中间


//2、指针的解引用

//int main()
//{
//	int a = 10;
//	int* p = &a;
//	int b = *p;//解引用：代表的是拿出p变量里面的内容，*p最终访问的也就是a，*p在表达式的右侧，
//	//换言之就是a的右值，也就是10，也就相当于*p等价于10
//	*p = 20;//解引用：*p,访问p变量，找到p变量里面的内容，p变量里面的内容是a的地址，也就是访问a，
//	//也就是访问的是*p 的空间，代表的是右值，也就是a的空间的概念
//
//	//相同的东西，但是放的位置不同时，也就相应的不同，根本原因也就是左值和右值不同的原因
//
//	//在同类型情况下，对指针解引用，代表指针所指向的目标
//
//	return 0;
//}

	//结论：*p完整理解是，取出p中的地址，访问该地址指向的内存单元(空间或者内容)（其实通过指针变量访问，
//本质是一种间接寻址的方式）
//口诀：对指针解引用，就是指针指向的目标。所以*p,就是a


//int main()
//{
//	*((double*)0) = 10.0;
//	//这个肯定是会崩溃的
//	//官方理由：0x00007FF6C9A71773 处(位于 test 2022-2-27 Understand Pointers and arrays in depth.exe
//	//中)引发的异常: 0xC0000005: 写入位置 0x0000000000000000 时发生访问冲突。
//
//	int* p = NULL; // NULL -> 0
//	*p = 10.0;
//	//这个也是会崩溃的
//	//官方理由：0x00007FF6446D1B83 处(位于 test 2022-2-27 Understand Pointers and arrays in depth.exe 
//	//中)引发的异常: 0xC0000005: 写入位置 0x0000000000000000 时发生访问冲突。
//	return 0;
//}

//写入位置 0x0000000000000000 时发生访问冲突。这种访问方式就是直接去访问0号地址，然后放不进去，就报错了
//* p = 10.0;//这就是直接去进行访问，所以报错了

//int main()
//{
//	double* p = NULL;
//	double x = *p;
//	//崩溃原因是：引发了异常: 读取访问权限冲突。p 是 nullptr。
//	//编译器的不同有时候报出来的问题就不同
//	//也是：写入位置 0x0000000000000000 时发生访问冲突。这个错误
//	return 0;
//}


//3、int* p = NULL和 *p = NULL的区别？

//int main()
//{
//	int a = 0;
//	int* p = NULL;
//	p = NULL;
//	*p = NULL;
//
//	//NULL : #define NULL ((void *)0)
//	//NULL,0,'\0'=====>数字层面都是0  但是类型是不一样的，有时候使用的类型不同时，编译器可能会进行报错或者
////会出现警告
//	
//
//	return 0;
//}

//下面是书中的内容：
	//int *p=NULL;
//这时候我们通过编译器查看p的值为0x00000000。这句代码的意思是：定义一个指针变量p，其指向的内存里面保存的是
//int类型的数据；在定义变量p的同时把p设置为0x00000000，而不是把*p的值设置为0x00000000.这个过程叫做初始化，
//是在编译的时候进行的。

//int* p=NULL;
//*p=NULL;
//同样，我可以在调试器上调试这两行代码。第一行代码，定义了一个指针变量p，其指向的内存里面保存的是int类型的
//数据；但是这时候变量p本身的值是多少不得而知，也就是说现在变量p保存的有可能是一个非法的地址。第二行代码，
//给*p赋值为NULL，即给p指向的内存赋值为NULL，但是由于p指向的内存可能是非法的，所以调试的时候，调试器可能
//会报告一个内存访问的错误。这样的话，我们可以把上面的代码进行改写，使p指向一块合法的内存。

//int i = 10;
//int* p = &i;
//*p = NULL;

//在调试器上调试一下就会发现p指向的内存由原来的10变成了0；而p本身的值，即内存地址并没有改变
//上面有行代码#define NULL ((void*)0)
//这里说明需要注意的是NULL就是NULL，它被宏定义为0

//4、如何将数值存储到指定的内存地址

//知道了指针的本质就是地址，地址就是数据
//目前主流的编译器和操作系统，为了安全，已经有很多的内存保护的机制。我们目前的win和Linux都有 栈随机化 这样
//的机制来方式黑客对用户数据地址进行预测。当然，还有其他的栈保护机制，比如：“金丝雀”技术之类的

//经过试验，目前VS和Centos7上，使用C语言定义的局部变量，在每次运行的时候，地址都是不同的，经过试验发现，
//定义全局变量，酶促更改代码，地址也会发生相应的变化，所以这个试验没法正确做出来，但是程序崩溃，也能说明
//问题


////int x = 10;这样子定义的全局变量所打印出来的地址是不变的
////当成下面这种情况时：
//int x = 10;
//int y = 20;
////这样子 x 的地址才发生了变化
////如果这样呢？：
//int y = 20; 
//int x = 10;
////这样子打印出来x的地址跟上面又是不同的
//
//int main()
//{
//	int a = 10;
//	printf("%p\n", &a);
//	printf("%p\n", &x);
//	//每次打印的时候地址都不相同，这是编译器所给出的结果,这种技术叫做栈随机化
//
//	return 0;
//}

//所以，只有栈上的变量的地址是随机的，全局变量的地址可能会发生改变

//不进行栈随机化的话，有些黑客可能会预测到相应的地址起的是什么作用

//int main()
//{
//	int a = 10;//假设a变量的地址是0x12345678，那么访问a变量，还可以直接通过指针方式进行访问
//	printf("%d\n", *(int*)0x12345678);//本质是一种直接寻址的方式，0x12345678叫做指针
//	*(int*)0x12345678 = 100;		  //本质是一种直接寻址的方式
//	//所以C语言通过 int* p=&a;这种指针变量的方式，访问目标数据的好处
//
//	return 0;
//}//这是会崩溃的


//int main()
//{
//	int a = 10;
//	int* p = &a;	//这是指针变量
//	printf("%d\n", *p);
//	*p = 20;
//	return 0;
//}//这样子就没问题，与上面相比肯定是下面的比上面的好用的多，所以一般只用的是下面的而不用上面的

//5、编译器中的BUG

//int main()
//{
//	int* p = NULL;//指针变量p
//
//	printf("%d\n", sizeof(p));//在32位平台下，它的大小是4个字节，在64位平台下，它的大小是8个字节
//
//	p = (int*)&p;//p中放的是p变量的地址，（左右两边的类型不同所以需要强转，在&p中，它的类型是int**,二级指针）
//
//	//这两个的作用是什么？
//	*p = 10;//*p,解引用是什么意思，理解1、访问p的右值，相当于p的内容，p的内容放的就是p的地址，所以就是把10放在
//	//p变量中，理解2、对指针解引用，代表指针所指向的目标，当前的p指向的就是p变量，所以，解引用之后就是p
//	//
//	p = 20;
//	*p = 30;//加上这句话就会报错，原因是*p=10，的地址是0x0000000a,p=20是将0x0000000a改成了0x00000014
//	//*p=30访问的是0x000000014,所以会报错，越界访问了
//	return 0;
//}

//数组
	//概念：数组是具有相同数据类型的集合
//1、数组的内存布局

	//C程序地址空间：
//最下面是低地址处，最上面是高地址处
//自下而上分别是：代码区；字符常量区；已初始化全局数据区；未初始化全局数据区；堆区；栈区；
//栈区：栈区整体向下增长，即：地址减少方向

//#define NUM  10
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	printf("%p\n", & a);// 00DCF8D0
//	printf("%p\n", & b);// 00DCF8C4
//	printf("%p\n", & c);// 00DCF8B8
//					//会发现整体地址是减少的
//	return 0;
//}

//上面是进行三个变量的定义，发现了地址空间的规律，如果定义数组，那会是怎么样的？
//#define NUM 10
//int main()
//{
//	int arr[NUM] = { 0 };
//	for (int i = 0; i < NUM; i++)
//	{
//		printf("arr[%d]:%p\n", i, &arr[i]);
//	}
//	return 0;
//}
//arr[0]:008FF6E0
//arr[1]:008FF6E4
//arr[2]:008FF6E8
//arr[3]:008FF6EC
//arr[4]:008FF6F0
//arr[5]:008FF6F4
//arr[6]:008FF6F8
//arr[7]:008FF6FC
//arr[8]:008FF700
//arr[9]:008FF704

//这十个数组也是在栈上开辟的
//栈：第一个元素先入栈的，入栈就到了低地址处，所以数组是：线性连续且递增！
//在开辟空间的角度，不应该将数组认为成为一个个独立的元素，而数组应该整题开辟空间，整体释放
//下标永远是++

//我们发现：数组的地址排布是：&a[0]<&a[1]<&a[2]<&a[3]<&a[4]<.....<&a[9]
//该数组在main函数中定义，那么也同样在栈上开辟空间
//数组有多个元素，那么肯定是a[0]先被开辟空间啊，那么肯定&a[0]地址最大啊，可事实上并非如此！
//数组是整体申请空间的，然后将地址最低的空间，作为a[0]元素，以此类推！

//由此：低地址处存放的是数组首元素的地址

//2、理解&a[0]&a的区别

//int main()
//{
//	char* c = NULL;
//	short* s = NULL;
//	int* i = NULL;
//	double* d = NULL;
//
//	printf("%d\n", c);       //0
//	printf("%d\n\n", c + 1);   //1
//
//	printf("%d\n", s);       //0
//	printf("%d\n\n", s + 1);   //2
//
//	printf("%d\n", i);       //0
//	printf("%d\n\n", i + 1);   //4
//	
//	printf("%d\n", d);       //0
//	printf("%d\n\n", d + 1);   //8
//	return 0;
//}

//对指针+1.看似是+1，其实是+上其指向类型的大小（也就是地址的大小）
//上面这个是大部分的情况，除非有强制转换，强制转换看的是强转之后的类型

//int main()
//{
//	int a = 10;
//	double* d = (double*)&a;
//
//	double** p = NULL;
//
//	printf("%d\n", p);          //0
//	printf("%d\n", p + 1);      //4
//	//p指向的是指针变量，在32位下指针变量就是4
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	double* d = (double*)&a;
//	double********************** p = NULL;
//	printf("%d\n", p);					//0
//	printf("%d\n", p + 1);				//4
//	//不管你指向的是几级指针，他都是指针变量，所以他就是4
//	return 0;
//}
////二级指针及其往上所有的指针+1，都是+sizeof(指针)       32位下：4个字节
//													//  64位下：8个字节



//数组名使用的时候，代表整个数组：
//1、&arr：表示的是数组的地址
//2、sizeof(arr):单独使用数组名：


//#define NUM 10
//int main()
//{
//	char arr[NUM] = { 0 };
//	printf("%p\n", &arr[0]);//数组首元素地址      //010FF87C
//	//这里是先进行取地址，还是先进行中括号：是先进行中括号的，中括号的优先级比取地址要高
//	printf("%p\n", &arr[0] + 1);//地址就是指针，地址+1，就是加上这个类型的大小   //010FF87D
//
//	printf("%p\n", &arr);//数组的地址							//010FF87C
//	printf("%p\n", &arr + 1);//+1是加上整个数组的大小			//010FF886
//	//&arr指向的数组的地址，&arr+1就是指向下一个数组
//	//这两个相差十，为什么是十，因为数组是char类型的，并且是有十个元素
//	return 0;
//}


//&arr[0]和&arr虽然地址数字一样大，但是类型意义完全不同

//为什么&arr[0]和&arr的地址值是一样的？
	//因为首元素的地址和数组的地址在地址对应的字节是重叠的，所以地址数据值相等

//3、数组名a作为左值和右值的区别？

//#define NUM 10
//int main()
//{
//	char arr[NUM] = { 0 };
//	char* p = arr;//这里说明数组名是可以做右值的，并且在做右值的时候，数组是首元素地址
//	char* q = &arr;//这里是会有警告的，这个叫做数组指针，这样子写两边的类型是不一样的，所以出现了警告
//	
//	printf("%p\n", p);				//0090FB90
//	printf("%p\n", arr);			//0090FB90
//	
//	return 0;
//}


//#define NUM 10
//int main()
//{
//	char arr[NUM] = { 0 };
//	//arr = { 1,2,3,4,5 };  //这是不对的，整体赋值是不对的
//	//这里就会出现错误，这种语法是错误的，也就是说数组只能够进行整体初始化，不能进行整体赋值，
//	//不能作为左值
//
//	arr[0] = 10;//只能一个一个进行赋值
//
//	return 0;
//}


//指针和数组的关系（注意：指针和数组是两码事，指针是指针，数组是数组）

	//1、以指针的形式访问和以数组的形式访问

	//int main()
//{
//	//C语言是没有字符串类型的
//	 const char* str = "hello bit";
//	//这个char是在栈上进行开辟的空间，那这个字符串是在哪里进行保存的呢？
//	//答案并不是在栈上保存的，而是在字符常量区进行保存的，意味着str保存的是指向字符串的起始位置的地址
//	//当main函数退出的时候，栈上的str就会被释放，在释放之后，而字符常量区的“hello bit”依旧存在
//	char buffer[] = "hello wworld!";
//	//这里是定义了一个数组，是在栈上开辟空间的，在栈上开辟若干个空间自下而上保存的分别是h e l ... \0
//	//当数组释放掉之后，这个字符串也会相应的被释放掉
//
//	*str = 'h';
//	//这里报错原因是前面加着一个const，把const一删，编译通过了，但是最后还是在报错
//	//访问的时候发生访问冲突
//	//编译的时候，编译通过了，那就不是代码的问题，但是在运行的过程中出现了错误，那就是操作系统出现了事了
//	
//	/*
//	const char* str="hello world";
//	char* p=(char*)str;
//	*p='h';
//	char buffer[]="hello world!"
//	这种虽然是绕开了编译器，但是依旧绕不开操作系统。操作系统是怎么都绕不开的
//	
//	*/
//
//	return 0;
//}


//int main()
//{
//	const char* str = "hello bit!";
//	char buffer[] = "hello world!";
//	int len = strlen(str);
//	for (int i = 0; i < len; i++)
//	{
//		printf("%c ", *(str + i));
//	}
//	//这是指针方式逐字符打印
//	printf("\n");
//	len = strlen(buffer);
//	for (int i = 0; i < len; i++)
//	{
//		//printf("%c ", buffer+i);//数组名在大部分表达式中，代表的是首元素的地址
//		printf("%c ", buffer[i]);
//	}
//	//采用数组方式也可以进行输出的
//	return 0;
//}

//指针与数组，在访问多个连续元素的时候，可以指针解引用方案，也可以[]方案


////例子:
//#include <string.h>
//#define N 10
//int main()
//{
//	char* str = "abcdef";//str指针变量在栈上保存，“abcdef”在字符常量区，不可被修改
//	char arr[] = "abcdef";//整个数组都在栈上保存，可以被修改
//
//	///////1、以指针的形式访问指针和以下标的形式访问指针
//	printf("以指针的形式访问指针和以下标的形式访问指针\n");
//	int len = strlen(str);
//	for (int i = 0; i < len; i++)
//	{
//		printf("%c\t", *(str + i));
//		printf("%c\n", str[i]);
//	}
//	printf("\n");
//
//
//	///////2、以指针的形式访问数组和以下标的形式访问数组
//	printf("以指针的形式访问数组和以下标的形式访问数组\n");
//	len = strlen(arr);
//	for (int i = 0; i < len; i++)
//	{
//		printf("%c\t", *(arr + i));
//		printf("%c\n", arr[i]);
//	}
//	printf("\n");
//
//	return 0;
//}

//结论：指针和数组指向或者表示一块空间的时候，访问方式是可以互通的，具有相似性。但是具有相似性，不代表是
	//一个东西或者具有相关性
//数组的效率要比指针快




//为什么C要这样子设计指针和数组的？


//void showArray(int arr[], int num)
//{
//	//通过传参的方式传给了showArray，那么这个传过去的arr是否是数组？
//	printf("%d\n", sizeof(arr));    //编译器所给的答案是4，而不是20，那为什么呢？？
//	//这里所传过去的arr的类型其实是int* arr
//	//通过调试窗口可以看出，arr的类型是int*类型的
//
//	for (int i = 0; i < num; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//}
//int main()
//{
//	int arr[] = { 1,2,3,4 };		//初始化数组，数组的大小是自动指定的
//	printf("main:%d\n", sizeof(arr));
//	int num = sizeof(arr) / sizeof(arr[0]);	//求数组元素的个数
//	
//	//sizeof(arr[0])，问题是数组的下标为什么是0，
//		//其实写1或者2都是可以的，标准的是0，那为什么是0呢？
//	//原因是元素至少是有一个，所以0这个元素是绝对存在的
//
//	showArray(arr, num);
//	return 0;
//}

//结论：1、数组传参，发生降维，需要降成指针

//问题：2、为什么要降维？
	//如果不降维：(首先有一个概念：C语言中，只要调函数，就要形成临时拷贝)
		//这就意味着，函数在调用，调用的时候就要发生数组的全拷贝，就会发生函数调用的效率较低
		//降维成指针，为什么降维成指针，因为指着在32位下或64位下的大小是确定的
		//降维之后，在函数调用的时候是否发生了临时拷贝？？
		// 降维成指针，指针变量那也是变量，所以在降维成指针之后，还是会发生拷贝
		// 在main中的数组地址和函数中的数组地址，将其打印出来之后，两个的地址是不一样的
		// 所以，这里是发生了函数拷贝，在函数中将int arr改成int* arr是一样的
		// 换言之也就是在进行函数传数组中，传递的是数组的首元素地址
		
//3、降维成什么？
	//所有数组，传参都会降维成指针，指针的类型有很多，那降维成什么类型的指针呢？？
		//降维成为指向其内部元素类型的指针！
		//如果数组是整形，则降维成整形指针，如果是字符型，则降维成字符型指针
//4、在C中，任何函数调用，只要有形参实例化，必定形成临时拷贝！！！ 
//5、在传参的时候，函数部分int arr[]，这样子就可以，不用写具体的数字，当写具体的数字的时候，也可以，
	//不过没有什么影响，中括号中的数字是可以忽略掉的

//6、C是面向过程语言，最重要的一个概念就是	函数	，需要什么功能，我就编写什么功能，需要什么，编写什么
	//这种就是面型过程语言，函数是核心概念，就离不开	定义与调用函数	，就会出现传参，又有数组
	//就要考虑数组传参，为了考虑效率问题，就要发生降维，降维成了指针

//void showArray(int* arr, int num)
//{
//	for (int i = 0; i < num; i++)
//	{
//		printf("%d ", *(arr + i));//这是进行指针打印，这里进行调用数组之后，这里的数组已经不是数组了，
//							      //而是指针1
//	}
//}

//在数组中进行元素访问就要进行arr[]进行访问

//7、假设指针和数组访问元素的方式不通用，就给程序员提出非常高的要求：
	//程序员需要不断在不同的代码片段处，进行习惯的切换，如果传了大量的数组，就要想到底是数组传过来的
	//还是指针传过来的，所以在非常大的代码量的时候，程序员们一定会出错的。
	//为了让程序员统一使用数组，减少出错的概率，就将数组和指针的访问方式设计成通用的，所以在函数部分
	//遍历整个数组的时候，就可以统一使用数组的方式进行遍历
//8、所以整个降维过程，对用户是透明的

//所以，由于C语言是被用的，那么不同的语法，使用上越统一，那么节省的就是人的精力

//结论：数组名只有在两种情况下表示的是整个数组
	//1、sizeof中
	//2、取地址数组名


//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n", sizeof(arr));//40
//	printf("%p\n", &arr);//00A2FA70
//	printf("%p\n", &arr+1);//00A2FA98
//					//这里加的是40，第一个地址到第二个地址之间相差40
//	return 0;
//}

////这道题是解释指针向后移动位数的问题
//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	//这里是有5个数组，其下标依次是[0]、[1]、[2]、[3]、[4]
//	//从左到右也就是从0到4的地址数是依次增大的，底层会自动做大小端转换的
//	int* ptr = (int*)(&a + 1);
//	//&a在数字层面上，就对应的是首元素的地址，是一个常数，是一个字面值常量
//	//这个数组可能前面还会有空间，后面还会有空间，刚开始int* ptr指向的是首元素的地址，+1是对指针+1
//	//所以加的其是它类型的大小，也就是其整个数组的大小，也就是加到了最后一个元素5的后面
//	printf("%d,%d", *(a + 1), *(ptr - 1));
//	//但是在这里的ptr-1是从最后一个元素5后面向前移动到4的后面，5的前面
//	//问题：这里的ptr-1会是ptr改变吗？答案是没有变，原因是ptr是一个变量，减号是一个运算符
//	//所以这里的ptr没有变，如果想让ptr改变的话，就需要赋值也就是等号  ptr=ptr-1;
//	//其实是ptr是没有进行变化的，只是ptr的结果发生变化了，对其进行解引用，对指针进行解引用，就是指向了
//	//指针所指向的目标，所以这里取出来的值是5
//
//	//这里的数组名参与了表达式，所以这里的a表示的是首元素的地址，+1向后移动一位，指向了2的位置，解引用，
//	//指向了指针所指向的目标，所以这里就是2
//	return 0;
//}

//结论：&a叫做数组的地址，a做右值叫做数组首元素的地址，本质是类型不同，进而进行+-计算步长不同

	//2、指针和数组的特性

//存储的内容：
	//数组：
		//保存数据，数组名a代表的是数组首元素的首地址，而不是数组的首地址。&a才是整个数组的首地址。a本身
	  //的地址由编译器另外存储，存储在哪里，我们并不知道
	//指针：
		//保存数据的地址，任何存入指针变量p的数据都会被当作地址来处理。p本身的地址由编译器另外存储，存储
	  //在哪里，我们并不知道

//访问数据的方式：
	//数组：
		//直接访问数据，数组名a是整个数组的名字，数组内每个元素并没有名字，只能通过“具名+匿名”的方式来
	  //访问其某个元素，不能把数组当一个整体来进行读/写操作。数组可以以指针的形式访问*（a+i）；也可以下
	  //标的形式访问a[i]，但其本质都是a所代表的数组首元素 的首地址加上i*sizeof（类型）字节作为数据的真正
	  //地址
	
	//指针：
		//间接访问数据，首先取得指针变量p的内容，把它作为地址，然后从这个地址提取数据或向这个地址写入数据。
	  //指针可以以指针的形式访问*(p+i);也可以以下标的形式访问p[i]，但其本质都是先取p的内容然后加上
	  //i*sizeof(类型)字节作为数据的真正地址

//常用场合：
	//数组：
		//通常用于存储固定数据且数据类型相同的元素
	//指针：
		//通常用于动态数据结构	

//分配删除：
	//数组：
		//隐式分配和删除（其实这里也可以malloc但是这里malloc之后，是以指针进行访问的）
	//指针：
		//相关的函数为malloc和free

//变量含义：
	//数组：
		//自身即为数组名
	//指针：
		//通常指向匿名数据（当然也可指向具名数据）



//指针数组和数组指针

	//1、指针数组和数组指针的内存布局
//指针数组：
	//本质是数组，只是数组里面放的是指针

//下面哪个是指针数组？哪个是数组指针？
//1）int* p1[10];    //（整形）指针数组
//2) int (*p2)[10];  //（整形）数组指针  ，指针变量，类型是指针

//[]的优先级要比*号的优先级高
//1）先于数组结合，所以就有了数组的概念，所以这里是指针数组

//int main()
//{
//	int* p1[10];	//整形指针数组，数组内部，后面可以放置任何类型（内置，*，struct,union,数组）的内容！
//	int(*p2)[10];	//整形数组指针，指针可以指向任何合法的类型变量
//
//	int(*p2)[5];//这是数组指针，是一个变量，占四个字节
//	int(*p[4])[5];//这是数组指针数组
//	int(*(*p)[4])[5];//数组指针数组的指针
//	
//	int a[10];//数组中的数字是否是数组类型的一部分？
//			//是
//
//	int(*p)[10] = &a;//这个p是数组指针变量，占四个字节
//			//a叫做首元素地址，但是这是个指针，所以不能初始化a而要初始化&a
//	return 0;
//}


//地址的强制类型转换
	//强制类型转化，究竟在做什么？？
		//本质上就是影响我们看待数据的方向，实质数据本身并没有发生任何变化
//结论：强制类型转化：改变的是对特定内容的看待方式，在C中，就是只改变了其类型
	//进行强制类型转化，一定是要改变数据本身的

//int main()
//{
//	int a = 97;
//	printf("%d\n", a);			//97
//	printf("%c\n", (char)a);	//a
//
//	return 0;
//}


////地址强转
//int main()
//{
//	int a = 0x11223344;
//	int* p = &a;
//	char* q = (char*)p;
//
//	printf("%x\n", p);
//	printf("%x\n", p + 1);//指针加1表示的是加上其所指类型的大小
//
//	printf("%x\n", p);
//	printf("%x\n", (char*)p + 1);//这样子+1就是加类型的大小，也就是1
//	return 0;
//}

//struct Test
//{
//	int num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p=(struct Teat*)0x100000;
//int main()
//{
//	printf("%d\n", sizeof(struct Test));//20
//	
//	printf("%p\n", p + 0x1);//00100014(0x100000+20(十进制)=0x100014)
//	printf("%p\n", (unsigned long)p + 0x1);//00100001(这不是指针，就是平常的整型)
//	printf("%p\n", (unsigned int*)p + 0x1);//00100004
//	return 0;
//}


//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//	printf("%x,%x\n", ptr1[-1], *ptr2);//4,2000000	//这里存数据存的是0x00000002，取的时候就是0x02000000
//	return 0;
//}

//这里画图还是比较麻烦的，在第23节课，1小时25分钟
//这里会出现大小端的问题，很多并且基本上的电脑都是小端的电脑

//存数据的时候是根据大小端问题继续，那么取数据的时候呢，也是要考虑大小端的问题




//多维数组和多级指针

//二维数组的理解：
	//理解链：
	//数组的定义是：具有相同的数据元素类型的集合，特征是，数据中可以保存任意类型。
		//那么数组中可以保存数组吗？     答案当然可以！
		//在理解上，我们甚至可以理解成所有的数组都可以当成“一维数组”！
	//就二维数组来说，我们认为二维数组，可以被看作是“一维数组”，只不过内部“元素”也是一维数组

	//那么内部一维数组是在内存中的布局是“线性连续且递增”的，多个该一维数组构成另一个“一维数组”，那么
	//整体使也是线性连续且递增

	//这也就解释了，下面地址为何是连续的

	//我们认为：二维数组可以看作内部元素是一维数组的一维数组


//int main()
//{
//	char a[3][4] = { 0 };
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("a[%d][%d]:%p\n", i, j, &a[i][j]);
//		}
//	}
//	return 0;
//}

//显示结果：
//a[0][0] : 00CFFAAC
//a[0][1] : 00CFFAAD
//a[0][2] : 00CFFAAE
//a[0][3] : 00CFFAAF
//a[1][0] : 00CFFAB0
//a[1][1] : 00CFFAB1
//a[1][2] : 00CFFAB2
//a[1][3] : 00CFFAB3
//a[2][0] : 00CFFAB4
//a[2][1] : 00CFFAB5
//a[2][2] : 00CFFAB6
//a[2][3] : 00CFFAB7

//结论：二维数组在内存地址空间排布上，也是线性连续且递增的

//如何画图呢？？
	//参考PDF第三讲


//int main()
//{
//	char c[4][3] = { 0 };
//	char* p = c;
//	//这里需要不需要告警
//	//c在这里表示的是首元素地址（而是一个数组！！！char[3]）的地址
//	//这里一定会有告警
//	//“初始化”:“char *”与“char (*)[3]”的间接级别不同
//	
//	printf("%p\n", &c); //00CFF740
//		//整个数组的地址
//	printf("%p\n", c);//00CFF740
//		//第一个元素的地址
//	printf("%p\n", &c[0][0]);//00CFF740
//		//第一个元素的第一个char类型的地址
//
//	//这三个是三位一体的
//
//	printf("%p\n", &c + 1);//00CFF74C
//		//这里+1，加的是整个数组的距离，也就是4*3=12
//	printf("%p\n", c + 1);//00CFF743
//		//这里+1 加的是一行元素，也就是三个元素，这里要理解二维数组[4][3]表示的是每个一维数组有三个元素
//	//这里一共有4个这样的数组
//
//	printf("%p\n", &c[0][0] + 1);//00CFF741
//		//这里的+1,表示的是加一个元素的大小（char）
//	return 0;
//}

//#include <windows.h>
//int main()
//{
//	int a[3][4] = { 0 };
//		//如何看成是一维数组呢？
//			//一维数组中的元素含有4个，共有3个这样的数组
//	printf("%d\n", sizeof(a));//什么含义？数组名补充：两种情况代表整个数组，其他都是首元素地址
//								//1、sizeof中单独使用数组名，2、取地址数组
//	//48
//		//3*4*4=48
//	printf("%d\n", sizeof(a[0][0]));//什么含义？
//	//4
//		//第一个元素的大小
//	printf("%d\n", sizeof(a[0]));//什么含义？
//	//16
//		//第一行的大小：4*4=16
//	printf("%d\n", sizeof(a[0] + 1));//什么含义？
//	//4
//		//a[0]第一个元素，第一个元素是数组，一个元素的数组名（名字），+1之后就表示首元素地址（就是指针），也就是int类型的
//	printf("%d\n", sizeof(*(a[0] + 1)));//什么含义？
//	//4
//		//第一个元素的数组名，也就是第一个元素的指针，+1之后就是第一行第二个地址，
//		//解引用就是第一行第二个元素，大小是int类型的，就是4，等价于a[0][1]
//	printf("%d\n", sizeof(a + 1));//什么含义？
//	//4
//		//这里便表示的是数组名作为表达式的一部分，此时的数组名表示是的首元素的地址，
//		//+1就表示的是第一行第二个元素的地址（数组指针的概念）
//	printf("%d\n", sizeof(*(a + 1)));//什么含义？
//	//16
//		//a代表的是数组名也就是第一个数组的地址，+1就是第二个数组的地址，
//		//解引用就是整个数组的地址,也就是4*4=16
//	printf("%d\n", sizeof(&a[0] + 1));//什么含义？
//	//4
//		//a[0]代表的是第一个元素，+&就是第一行第一个元素的地址，+1就是第二行第一个元素的地址
//		//是地址，它的大小就是4
//	printf("%d\n", sizeof(*(&a[0] + 1)));//什么含义？
//	//16
//		//上面说到里面是第二个数组第一个元素的地址，再解引用就是第二个数组，整个的大小
//		//上上个与这个是等价的
//	printf("%d\n", sizeof(*a));//什么含义？
//	//16
//		//这里表示的是整个数组，也就是第一个数组的首元素地址。解引用就是整个元素的大小
//	printf("%d\n", sizeof(a[3]));//什么含义？
//	//16
//		//a[0]代表的是第一个数组的首元素地址，很显然3已经是越界了，但是在C语言中只需要进行检测是不会
//	//出现问题的，所以这里就代表的是整个数组的大小，就是16
//
//	system("pause");
//	return 0;
//}

/*
int a = 10;
int* p = &a;
*/
//*p  :  对指针解引用就是代表指针指向的目标，就是	a	!!


//int main()
//{
//	//数组[]中的数字，也是类型的一部分
//	int a[5][5];
//	int(*p)[4];//数组指针，整形指针，本质“数组”也是一种类型！！
//	p = a;//这里会出现告警，int*[4]  和   int*[5]，，这里出现了告警，其实就是类型不同
//	printf("a_ptr=%p,p_ptr=%p\n", &a[4][2], &p[4][2]);
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//	//此题讲解在第24讲，深度理解指针和数组（5）中第1小时08分钟
//	//a比p大，a[4][2]指向的是第5个数组 组 中的第2个元素末尾
//	//p[4][2]，指向的是第4个数组 组 的第二个元素的末尾
//	//所以之间相差	4	个
//	//所以以%d来进行打印的话就是-4，之间相差4个元素
//
//	//-4：
//	//1000 0000 0000 0000 0000 0000 0000 0100    --源码
//	//1111 1111 1111 1111 1111 1111 1111 1011    --反码
//	//1111 1111 1111 1111 1111 1111 1111 1100    --补码
//	//0x F    F    F    F    F    F    F    C
//	return 0;
//}


//&p[4][2] 等价于p[4][2] 等价于* (*(p + 4) + 2)

//会不会更改p的值呢？答案是不会的，p并没有被赋值，所以不会改变p的值


//int main()
//{
//	int a[10] = { 0 };
//	int* p = a;
//	int* q = &a[9];
//	//把上面改成short类型，下面打印的还是9，所以这就表明。两个指针相减，答案就是两个指针之间的元素个数
//	printf("%d\n", q - p);
//	//p指向的是第一个位置，而q指向的并不是九后面的位置，而是九前面的位置，差距一共就有九个元素，
//	//打印出来的大小就是4*9=36
//	//但是答案并不是这样的：
//	//指针相减，代表指针之间所经历的元素的个数
//	return 0;
//}


	//二级指针
	
//int main()
//{
//	int a = 10;
//	int* p = &a;
//	int** pp = &p;
//
//	p = 100;
//	*p = 100;
//	pp = 100;
//	*pp = 100;
//	**pp = 100;
//
//	//二级指针存放的就是一级指针的地址，三级指针存放的就是二级指针的地址
//	return 0;
//}

//数组传参

//void show(int *p)		//p也是一个变量，会进行临时拷贝，形成形参实例化
//{
//	printf("show:%d\n", sizeof(p));//4
//	printf("show:%p\n", p);//00AFFE70
//	//这里可以看出上面的p是有临时变量的，所以这里就可以说明：（说明在void show处）
//	printf("show:%d\n", &p);//00AFFD9C
//}
//int main()
//{
//	int a[10];
//	printf("main:%d\n", sizeof(a));//40
//	show(a);
//	printf("main:%p\n", a);//00AFFE70
//	return 0;
//}

//数组传参
	//为何要进行降维？？
//如果不发生降维，数组传参就要发生硬拷贝，show函数进行调用的时候,就要将数组进行整体进行拷贝，就会导致调用
//函数的成本会比较多，所以就发生了降维，本质就是为了提高效率

//降维成什么？
	//降维成指向器内部元素类型的指针（为什么呢？？）
//根本原因就是其首元素的地址，在show(a)中传入的是数组名，这就是传入的是首元素的地址，
	//在降维的时候有没有发生临时拷贝？？
	// 上面的例子可以说明是有进行临时拷贝的

//void show(int a[],int num)//通常是可以将前面的维度进行忽略，里面放入10或者11或者5都是可以编译通过的
////换句话说就是可以将中括号中的数据忽略的
//{
//	printf("show:%d\n", sizeof(a));
//
//	for (int i = 0; i < num; i++)
//	{
//		printf("%d\n", a[i]);
//	}
//}
//int main()
//{
//	int a[10] = { 0 };
//	printf("main:%d\n", sizeof(a));//40
//	show(a,10);
//	printf("main:%p\n", a);//00AFFE70
//	return 0;
//}


//指针传参(一级)

//问题：在函数调用过程中，要不要发生临时拷贝？？
//void test(char* p)
//{
//	printf("test:&p=%p\n", &p);//test : &p = 00DDF660
//}
//int main()
//{
//	char* p = "hello world!";
//	printf("main:&p=%p\n", &p);//main:&p = 00DDF734
//	test(p);
//	return 0;
//}
//这是需要的，因为指针变量也是变量，在传参上，它也是必须符合变量的要求，进行临时拷贝的！


	//结论：在C语言中，只要函数调用，只要传入了参数，必定会发生临时拷贝，只不过要根据具体情况去决定，
//拷贝了什么，拷贝了多少！


//例子：
//#define N 10
//void GetStr(char** pp)
//{
//	*pp = malloc(sizeof(char) * N);
//	if (NULL != *pp)//如果字符串不等于空
//	{
//		//strcpy(*pp, "hello");//则将"hello"这个	字符串	拷入到	*pp	之中
//		strcpy(pp, "hello");//这里的pp是实参，上面*pp是形参，实参就进行了实例化
//		//在运行时，就出现了错误，所以上面这样子写出来就是错误的
//		//在传值传参和传址传参对于C语言来说是没有任何区别的
//	}
//	else
//	{
//		//do nothing!
//	}
//}
//int main()
//{
//	char* p = NULL;
//	GetStr(&p);
//	printf("%s\n", p);//打印出来的就是hello
//	return 0;
//}


//二维数组

	//二维数组是数组吗？
//所有数组传参，都要发生降维，降维成指针！！！
//那降维成什么指针呢？
	//还是降维成指向其内部元素的指针
//所有的数组，都可以看做成为一维数组！
// 不管是那种数组，在传参的时候都会降维成数组，降维成什么数组：指向其内部元素的指针
// 
//void print(int a[5][6])//第一个维度可以省略，那第二个，第三个维度可以被省略吗，
//	//答案就是不能被省略，除了第一个维度之外，其余的是不能进行省略的
////void print(int (*a)[6])
////void print(int (*a)[6][7][8][9])
//
//{
//
//}
//int main()
//{
//	int a[5][6] = { 0 };
//	//int a[5][6][7][8][9] = { 0 };//这里传参就是传上面的所对应的
//
//	print(a);//首元素的地址
//	return 0;
//}



//void print(int (*p)[] /*int a[][6]*/, int num)
////为什么除了第一个数组的下标可以省略，第二个数组下标之后的元素个数不能被省略？？？
////可以类比二维数组，行可以省略，列不能省略
//
////如果省略了第二个之后的下标，指针类型不明确
//{}
//int main()
//{
//	int a[5][6] = { 0 };
//	print(a, 5);//首元素的地址
//
//	////数组的下标也是数组类型的一部分
//	//int a[5][6];
//	//int(*p)[];
//	//上面两行会出现警告
//	return 0;
//}



//函数指针
	//函数其实也是有地址的


//void fun()
//{
//	printf("hello bit!\n");
//}
//int main()
//{
//	fun();
//	fun;
//	//上面这两种都是可以进行编译通过的，注意这里是可以编译通过的
//	return 0;
//}

	//上面这里可以编译通过，其表明的就是函数也是有地址的，但是为什么呢？
//CPU做的三个指令：取指令，分析指令，执行指令
//程序 = 数据 + 代码
	//为何函数也是含有地址的，原因是函数是代码的一部分，程序运行的时候，也要加载进内存，以供CPU后续寻址
//访问，换句话说，代码就是有地址的！


//函数的地址是什么样的？？

//void fun()
//{
//	printf("hello world!\n");
//}
//int main()
//{
//	//拿到函数的地址一共有两种方法：
//	printf("fun:%p\n", fun);//注意这里不能加括号，加括号的话就成了函数调用了
//	printf("fun:%p\n", &fun);
//
//	//fun:00C613A2
//	//fun:00C613A2
//	
//	//上面两个是等价的，没有任何区别的，也可以换句话来说是左值和右值的
//
//	//保存的话用下面这个：
//	void (*p)() = fun;
//	//调用用下面这个：
//	p();
//	return 0;
//}
//在函数中，函数只关心起始代码在哪里


//定义：
		//是一个指针，只不过是指向函数的，
	//void (*p)() = fun;    //括号的优先级要比*高，所以要对*p进行加括号

//函数的地址值已经被保存起来了，那如何进行调用呢？
	//(*p)解引用p放的就是函数的地址，*p也可以理解成取p的右值，也就是地址，
//(*p)(),左侧是函数地址，右侧是函数调用
	//还有一个简写：p();这两个是等价的。

//#include <string.h>
//char* fun(char* s1, char* s2)
//{
//	int i = stcmp(s1, s2);
//	if (0 == i)//字符串相等就返回s1,不相等就返回s2
//	{
//		return s1;
//	}
//	else
//	{
//		return s2;
//	}
//}
//int main()
//{
//	//funp先与*相结合，其类型是char*,返回列表为char* char* 的函数指针
//	char* (*funp)(char*, char*) = fun;
//	//调用的时候直接传两个字符串.
//	char* s =(*fun)("hello", "world");
//
//	printf(s);
//	return 0;
//}


//一个小游戏

//void Welcome()
//{
//	printf("#######################\n");
//	printf("   1.paly     2.Exit   \n");
//	printf("#######################\n");
//}
//void GetGift()
//{
//	printf("恭喜你获得玄黄皮肤!\n");
//}
//			//下面这个是函数指针
//void login(void (*Welcome)(), void(*GetGift)())
//{
//#define NAME "小学生"
//#define PASSWD "12345"
//	
//	char name[32];
//	char passwd[32];
//	printf("Please Enter Your Name:");
//	scanf("%s", name);
//	printf("Please Enter Your Passwd:");
//	scanf("%s", passwd);
//	if (strcmp(name, NAME) == 0 && strcmp(passwd, PASSWD) == 0)
//	{
//		Welcome();
//		GetGift();
//	}
//
//}
//int main()
//{
//
//	login(Welcome, GetGift);
//	return 0;
//}



void(*(*p)[10])();//函数指针数组的指针
void(*(*p[5])[10])();//函数指针数组的指针数组
//识别方式：从外部到内部进行识别，最右面的()代表的是函数


//指针就是地址；指针变量是一个变量；地址是一个数据，是数据就会被保存；保存地址数据的变量就是指针变量；
//指针+1看上去是+1，其实是加上其所指向类型的大小；指针进行所谓的解引用，代表指针所指向的目标；
//数组名作为参数传递的时候是要发生降维，降维成所指向内部元素类型的指针；